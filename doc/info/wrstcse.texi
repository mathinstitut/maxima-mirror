@menu
* Introduction to wrstcse::
* Functions and Variables for wrstcse::
@end menu

@node Introduction to wrstcse, Functions and Variables for wrstcse, Package wrstcse, Package wrstcse
@section Introduction to wrstcse

@code{wrstcse} is a naive go at interval arithmetics is powerful enough to
perform worst case calculations that appear in engineering by applying
all combinations of tolerances to all parameters.

This approach isn't guaranteed to find the exact combination of parameters
that results in the worst-case. But it avoids the problems that make a true
interval arithmetics affected by the halting problem as an equation can have
an infinite number of local minima and maxima and it might be impossible to
algorithmically determine which one is the global one.

Tolerances are applied to parameters by providing the parameter with a @var{tol[n]}
that wrstcase will vary between -1 and 1. Using the same @var{n} for two parameters
will make both parameters tolerate in the same way.

@code{load ("wrstcse")} loads this package.

@opencatbox{Categories:}
@category{Share packages}
@category{Package wrstcse}
@closecatbox

@node Functions and Variables for wrstcse, , Introduction to wrstcse, Package wrstcse
@section Functions and Variables for wrstcse

@anchor{wc_typicalvalues}
@deffn {Function} wc_typicalvalues (@var{expression}, [@var{num}])

Returns what happens if all tolerances (that are represented by @var{tol[n]} that can
vary from 0 to 1) happen to be 0.

Example:
@c ===beg===
@c load("wrstcse")$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 2000.0*(1+tol[2]*.01)
@c  ];
@c divider:U_Out=U_In*R_1/(R_1+R_2);
@c wc_typicalvalues(vals);
@c wc_typicalvalues(subst(vals,divider));
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 2000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 2000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) divider:U_Out=U_In*R_1/(R_1+R_2);
                                R_1 U_In
(%o3)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i4) wc_typicalvalues(vals);
(%o4)             [R_1 = 1000.0, R_2 = 2000.0]
@end group
@group
(%i5) wc_typicalvalues(subst(vals,divider));
(%o5)            U_Out = 0.3333333333333333 U_In
@end group
@end example
@end deffn

@anchor{wc_inputvalueranges}
@deffn {Function} wc_inputvalueranges (@var{expression}, [@var{num}])

Convenience function: Displays a list which parameter can vary between
which values.

Example:
@c ===beg===
@c load("wrstcse")$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 2000.0*(1+tol[2]*.01)
@c  ];
@c wc_inputvalueranges(vals);
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 2000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 2000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) wc_inputvalueranges(vals);
        [ R_1  min = 990.0   typ = 1000.0  max = 1010.0 ]
(%o3)   [                                               ]
        [ R_2  min = 1980.0  typ = 2000.0  max = 2020.0 ]
@end group
@end example
@end deffn

@anchor{wc_systematic}
@deffn {Function} wc_systematic (@var{expression}, [@var{num}])

Systematically introduces @var{num} values per parameter into @var{expression}
and returns a list of the result. If no @var{num} is given, @var{num} defaults
to 3.

See also @mref{wc_ewc_simplify} and @mrefdot{wc_montecarlo}

Example:
@c ===beg===
@c load("wrstcse")$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 2000.0*(1+tol[2]*.01)
@c  ];
@c divider: U_Out=U_In*(R_1)/(R_1+R_2);
@c wc_systematic(subst(vals,rhs(divider)));
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 2000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 2000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) divider: U_Out=U_In*(R_1)/(R_1+R_2);
                                R_1 U_In
(%o3)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i4) wc_systematic(subst(vals,rhs(divider)));
(%o4) [0.33333333333333337 U_In, 0.3311036789297659 U_In, 
0.3289036544850498 U_In, 0.3355704697986577 U_In, 
0.3333333333333333 U_In, 0.33112582781456956 U_In, 
0.3377926421404682 U_In, 0.3355481727574751 U_In, 
0.3333333333333333 U_In]
@end group
@end example
@end deffn


@anchor{wc_ewc_simplify}
@deffn {Function} wc_ewc_simplify (@var{expression})

Brute-forcing through all combinations of @var{tol[n]} in order to find the
worst-case combination is O(m^n)-complete and therefore computationally intensive
for high numbers of tol[n].

@code{wc_ewc_simplify} uses the sign of the derivatives of @var{expression} to combine
as many @code{tol[n]}, as possible. The result is an expression that might run much
faster through @code{wc_mintypmax} and @code{wc_systematic}, but that, if the derivate
of @var{expression} doesn't change sign in the @var{tol[n]} space, still yields the
same results for the brute-force approaches to worst-case analysis.

Note that changing the number of @var{tol[n]} will change the statistical distribution
of the results over the @var{tol[n]} space and therefore will change the statistical
distribution of the montecarlo method and the results of the root sum square functions.

See also @mref{wc_mintypmax} and @mrefdot{wc_montecarlo}

Example:
@c ===beg===
@c load("wrstcse")$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 2000.0*(1+tol[2]*.01)
@c  ];
@c ratprint:false;
@c assume(U_In>0);
@c divider: U_Out=U_In*(R_1)/(R_1+R_2);
@c divider_vals:subst(vals,divider);
@c divider_vals_simplified:lhs(divider_vals)=wc_ewc_simplify(rhs(divider_vals));
@c wc_systematic(rhs(divider_vals));
@c wc_systematic(rhs(divider_vals_simplified));
@c lhs(divider_vals)=wc_mintypmax(rhs(divider_vals));
@c lhs(divider_vals_simplified)=wc_mintypmax(rhs(divider_vals_simplified));
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 2000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 2000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) ratprint:false;
(%o3)                         false
@end group
@group
(%i4) assume(U_In>0);
(%o4)                      [U_In > 0]
@end group
@group
(%i5) divider: U_Out=U_In*(R_1)/(R_1+R_2);
                                R_1 U_In
(%o5)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i6) divider_vals:subst(vals,divider);
                        1000.0 (0.01 tol  + 1) U_In
                                        1
(%o6) U_Out = -----------------------------------------------
              2000.0 (0.01 tol  + 1) + 1000.0 (0.01 tol  + 1)
                              2                        1
@end group
@group
(%i7) divider_vals_simplified:lhs(divider_vals)=wc_ewc_simplify(rhs(divider_vals));
                        1000.0 (1 - 0.01 tol ) U_In
                                            2
(%o7) U_Out = -----------------------------------------------
              2000.0 (0.01 tol  + 1) + 1000.0 (1 - 0.01 tol )
                              2                            2
@end group
@group
(%i8) wc_systematic(rhs(divider_vals));
(%o8) [0.33333333333333337 U_In, 0.3311036789297659 U_In, 
0.3289036544850498 U_In, 0.3355704697986577 U_In, 
0.3333333333333333 U_In, 0.33112582781456956 U_In, 
0.3377926421404682 U_In, 0.3355481727574751 U_In, 
0.3333333333333333 U_In]
@end group
@group
(%i9) wc_systematic(rhs(divider_vals_simplified));
(%o9) [0.3377926421404682 U_In, 0.3333333333333333 U_In, 
                                         0.3289036544850498 U_In]
@end group
@group
(%i10) lhs(divider_vals)=wc_mintypmax(rhs(divider_vals));
(%o10) U_Out = [min = 0.3289036544850498 U_In, 
    typ = 0.3333333333333333 U_In, max = 0.3377926421404682 U_In]
@end group
@group
(%i11) lhs(divider_vals_simplified)=wc_mintypmax(rhs(divider_vals_simplified));
(%o11) U_Out = [min = 0.3289036544850498 U_In, 
    typ = 0.3333333333333333 U_In, max = 0.3377926421404682 U_In]
@end group
@end example
@end deffn

@anchor{wc_montecarlo}
@deffn {Function} wc_montecarlo (@var{expression}, @var{num})

Introduces @var{num} random values per parameter into
@var{expression} and returns a list of the result.

See also @mrefdot{wc_systematic}

Example:
@c ===beg===
@c load("wrstcse")$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 2000.0*(1+tol[2]*.01)
@c  ];
@c divider: U_Out=U_In*(R_1)/(R_1+R_2);
@c wc_montecarlo(subst(vals,rhs(divider)),10);
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 2000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 2000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) divider: U_Out=U_In*(R_1)/(R_1+R_2);
                                R_1 U_In
(%o3)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i4) wc_montecarlo(subst(vals,rhs(divider)),10);
(%o4) [0.3301505377099377 U_In, 0.33276843198354916 U_In, 
0.33406203454153227 U_In, 0.33434833585190965 U_In, 
0.3341006856369802 U_In, 0.3359647531928058 U_In, 
0.32911646313213117 U_In, 0.333158315034511 U_In, 
0.3325173140803672 U_In, 0.3331108406798784 U_In]
@end group
@end example
@end deffn

@anchor{wc_mintypmax}
@deffn {Function} wc_mintypmax (@var{expr}, [@var{n}])

Prints the minimum, maximum and typical value of @var{expr}. If @var{n}
is positive, @var{n} values for each parameter will be tried systematically.
If @var{n} is negative, @var{-n} random values are used instead.
If no @var{n} is given, 3 is assumed.

See also @mrefcomma{wc_mintypmax_rss} @mref{wc_ewc_simplify} and @mrefdot{wc_systematic}

Example:
@c ===beg===
@c load("wrstcse")$
@c ratprint:false$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 1000.0*(1+tol[2]*.01)
@c  ];
@c assume(U_In>0);
@c divider:U_Out=U_In*R_1/(R_1+R_2);
@c lhs(divider)=wc_mintypmax(subst(vals,rhs(divider)));
@c ===end===
@example
(%i1) load("wrstcse")$
(%i2) ratprint:false$
@group
(%i3) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 1000.0*(1+tol[2]*.01)
 ];
(%o3) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 1000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i4) assume(U_In>0);
(%o4)                      [U_In > 0]
@end group
@group
(%i5) divider:U_Out=U_In*R_1/(R_1+R_2);
                                R_1 U_In
(%o5)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i6) lhs(divider)=wc_mintypmax(subst(vals,rhs(divider)));
(%o6) U_Out = [min = 0.495 U_In, typ = 0.5 U_In, 
                                                max = 0.505 U_In]
@end group
@end example
@end deffn


@anchor{wc_mintypmax_rss}
@deffn {Function} wc_mintypmax_rss (@var{expr}, @var{sigmas})

Prints the minimum and maximum of @var{expr}, as well as how high the
probability is that @var{expr} will lie out of that range based on a root
sum square calculation and assuming all input ranges will be gauss-shaped.

@var{wc_defaultsigma} defines how many sigma of an input value's tolerance
distribution the range of @var{tol[n]}=[-1...1] corresponds to.

The RSS methods has a few advantages a brute-force worst-case calculation:
It is fast even witput @mref{wc_ewc_simplify}. It prevents overengineering
resulting from assuming all tolerances to add up in a catastrophical way if
this only happens in a neglectible number of cases. But it will yield only
the correct results if the gaussian distribution of the input data is known.

See also @mref{wc_defaultsigma} and @mrefdot{wc_mintypmax}

Example:
@c ===beg===
@c load("wrstcse")$
@c ratprint:false$
@c wc_defaultsigma:6$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 1000.0*(1+tol[2]*.01)
@c  ];
@c assume(U_In>0);
@c divider:U_Out=U_In*R_1/(R_1+R_2);
@c lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
@c ===end===
@example
(%i1) load("wrstcse")$
(%i2) ratprint:false$
(%i3) wc_defaultsigma:6$
@group
(%i4) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 1000.0*(1+tol[2]*.01)
 ];
(%o4) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 1000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i5) assume(U_In>0);
(%o5)                      [U_In > 0]
@end group
@group
(%i6) divider:U_Out=U_In*R_1/(R_1+R_2);
                                R_1 U_In
(%o6)                   U_Out = ---------
                                R_2 + R_1
@end group
@group
(%i7) lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
(%o7) U_Out = [min = 0.49646446609406725 U_In, typ = 0.5 U_In, 
 max = 0.5035355339059328 U_In, Fail = 0.0019731752898266564 ppm]
@end group
@end example
@end deffn

@anchor{wc_defaultsigma}
@defvr {Option variable} wc_defaultsigma
Default value: @code{6}

Defines how many sigmas of the gauss distribution that represents the
tolerances of a parameter correspond to a @var{tol[n]} value of -1...1.

See also @mrefdot{wc_mintypmax_rss}

Example:
@c ===beg===
@c load("wrstcse")$
@c ratprint:false$
@c vals: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 1000.0*(1+tol[2]*.01)
@c  ];
@c assume(U_In>0);
@c divider:U_Out=U_In*R_1/(R_1+R_2);
@c wc_defaultsigma:1$
@c lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
@c wc_defaultsigma:3$
@c lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
@c wc_defaultsigma:6$
@c lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
@c ===end===
@example
(%i1) load("wrstcse")$
(%i2) ratprint:false$
@group
(%i3) vals: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 1000.0*(1+tol[2]*.01)
 ];
(%o3) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 1000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i4) assume(U_In>0);
(%o4)                      [U_In > 0]
@end group
@group
(%i5) divider:U_Out=U_In*R_1/(R_1+R_2);
                                R_1 U_In
(%o5)                   U_Out = ---------
                                R_2 + R_1
@end group
(%i6) wc_defaultsigma:1$
@group
(%i7) lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
(%o7) U_Out = [min = 0.4787867965644036 U_In, typ = 0.5 U_In, 
 max = 0.5212132034355964 U_In, Fail = 0.0019731752898266564 ppm]
@end group
(%i8) wc_defaultsigma:3$
@group
(%i9) lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
(%o9) U_Out = [min = 0.49292893218813455 U_In, typ = 0.5 U_In, 
 max = 0.5070710678118655 U_In, Fail = 0.0019731752898266564 ppm]
@end group
(%i10) wc_defaultsigma:6$
@group
(%i11) lhs(divider)=wc_mintypmax_rss(subst(vals,rhs(divider)),6);
(%o11) U_Out = [min = 0.49646446609406725 U_In, typ = 0.5 U_In, 
 max = 0.5035355339059328 U_In, Fail = 0.0019731752898266564 ppm]
@end group
@end example
@end defvr

@anchor{wc_tolappend}
@deffn {Function} wc_tolappend (@var{list})

Appends two list of parameters with tolerances renumbering the tolerances of
both lists so they don't coincide.

Example:
@c ===beg===
@c load("wrstcse")$
@c val_a: [
@c    R_1= 1000.0*(1+tol[1]*.01),
@c    R_2= 1000.0*(1+tol[2]*.01)
@c  ];
@c val_b: [
@c    R_3= 1000.0*(1+tol[1]*.01),
@c    R_4= 1000.0*(1+tol[2]*.01)
@c  ];
@c wc_tolappend(val_a,val_b);
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) val_a: [
   R_1= 1000.0*(1+tol[1]*.01),
   R_2= 1000.0*(1+tol[2]*.01)
 ];
(%o2) [R_1 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_2 = 1000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i3) val_b: [
   R_3= 1000.0*(1+tol[1]*.01),
   R_4= 1000.0*(1+tol[2]*.01)
 ];
(%o3) [R_3 = 1000.0 (0.01 tol  + 1), 
                             1
                                    R_4 = 1000.0 (0.01 tol  + 1)]
                                                          2
@end group
@group
(%i4) wc_tolappend(val_a,val_b);
(%o4) [R_1 = 1000.0 (0.01 tol  + 1), 
                             2
R_2 = 1000.0 (0.01 tol  + 1), R_3 = 1000.0 (0.01 tol  + 1), 
                      1                             4
R_4 = 1000.0 (0.01 tol  + 1)]
                      3
@end group
@end example
@end deffn

@anchor{wc_mintypmax2tol}
@deffn {Function} wc_mintypmax2tol (@var{tolname}, @var{minval}, @var{typval}, @var{maxval})

Generates a parameter that uses the tolerance @var{tolname} that tolerates between the
given values.

Example:
@c ===beg===
@c load("wrstcse")$
@c V_F: U_Diode=wc_mintypmax2tol(tol[1],.5,.75,.82);
@c lhs(V_F)=wc_mintypmax(rhs(V_F));
@c ===end===
@example
(%i1) load("wrstcse")$
@group
(%i2) V_F: U_Diode=wc_mintypmax2tol(tol[1],.5,.75,.82);
                                         2
(%o2) U_Diode = - 0.09000000000000002 tol
                                         1
                                + 0.15999999999999998 tol  + 0.75
                                                         1
@end group
@group
(%i3) lhs(V_F)=wc_mintypmax(rhs(V_F));
(%o3) U_Diode = [min = 0.5, typ = 0.75, max = 0.8199999999999998]
@end group
@end example
@end deffn
